package heig.tb.jsmithfx;

import heig.tb.jsmithfx.logic.CircuitSimulator;
import heig.tb.jsmithfx.logic.HistoryManager;
import heig.tb.jsmithfx.logic.ProjectManager;
import heig.tb.jsmithfx.logic.SmithCalculator;
import heig.tb.jsmithfx.model.CircuitElement;
import heig.tb.jsmithfx.model.DataPoint;
import heig.tb.jsmithfx.model.Element.Capacitor;
import heig.tb.jsmithfx.model.Element.Inductor;
import heig.tb.jsmithfx.model.Element.Line;
import heig.tb.jsmithfx.model.Element.Resistor;
import heig.tb.jsmithfx.model.Element.TypicalUnit.FrequencyUnit;
import heig.tb.jsmithfx.model.TouchstoneS1P;
import heig.tb.jsmithfx.utilities.Complex;
import heig.tb.jsmithfx.utilities.ComponentEntry;
import heig.tb.jsmithfx.utilities.SmithUtilities;
import javafx.beans.binding.Bindings;
import javafx.beans.property.*;
import javafx.collections.FXCollections;
import javafx.collections.ListChangeListener;
import javafx.collections.ObservableList;
import javafx.stage.FileChooser;
import javafx.util.Pair;

import java.io.File;
import java.util.*;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.stream.Collectors;

import static org.controlsfx.tools.Utils.getWindow;

/**
 * The ViewModel for the Smith Chart application.
 * <p>
 * This class manages the state of the circuit, handles impedance calculations,
 * manages frequency sweeps, handles S1P data, and provides properties for UI binding.
 * It follows the Singleton pattern.
 * </p>
 */
public final class SmithChartViewModel {

    // =============================================================================================
    // Services & Logic Delegates
    // =============================================================================================

    /** Stateless service for calculating impedance chains and transformations. */
    private final CircuitSimulator simulator = new CircuitSimulator();

    /** Generic manager for Undo/Redo stack operations. */
    private final HistoryManager<UndoRedoEntry> historyManager = new HistoryManager<>();

    // =============================================================================================
    // Core Physics Properties
    // =============================================================================================

    /** The Characteristic Impedance (Z0) of the system (usually 50 Ohm). */
    public final DoubleProperty zo = new SimpleDoubleProperty();

    /** The base Load Impedance (ZL) at the start of the chain. */
    public final ObjectProperty<Complex> loadImpedance = new SimpleObjectProperty<>();

    /** The current operating frequency. */
    private final DoubleProperty frequency = new SimpleDoubleProperty();

    // =============================================================================================
    // Data Collections (Points & Elements)
    // =============================================================================================

    /**
     * The collection of all circuits (tabs).
     * Each element is an ObservableList of CircuitElements representing one circuit.
     */
    public final ObservableList<ObservableList<CircuitElement>> allCircuits =
            FXCollections.observableArrayList();

    /**
     * The index of the currently active circuit.
     */
    public final IntegerProperty circuitElementIndex = new SimpleIntegerProperty(0);

    /**
     * The currently active circuit.
     * This property is bound to the selected circuit in {@code allCircuits}.
     */
    public final SimpleListProperty<CircuitElement> circuitElements = new SimpleListProperty<>();

    /**
     * Retrieves the currently active circuit.
     * @return The active list of circuit elements.
     */
    public ObservableList<CircuitElement> getCircuit() {
        return circuitElements.get();
    }
    /**
     * Main calculation points.
     * Contains the cumulative impedance/gamma at each stage of the circuit.
     */
    private final SimpleListProperty<DataPoint> dataPoints = new SimpleListProperty<>(FXCollections.observableArrayList());

    /** Imported S1P file data points. */
    private final ReadOnlyListWrapper<DataPoint> s1pDataPoints = new ReadOnlyListWrapper<>(FXCollections.observableArrayList());

    /** S1P points transformed by the current circuit elements (for visualization). */
    private final ReadOnlyListWrapper<DataPoint> transformedS1PPoints = new ReadOnlyListWrapper<>(FXCollections.observableArrayList());
    private final List<DataPoint> cachedS1PPoints = new ArrayList<>();

    /** Points generated by the frequency sweep. */
    private final ReadOnlyListWrapper<DataPoint> sweepDataPoints = new ReadOnlyListWrapper<>(FXCollections.observableArrayList());
    private final SimpleListProperty<Double> pointToSweep = new SimpleListProperty<>(FXCollections.observableArrayList());

    /** Aggregated list of all points (Main + S1P + Sweep) for rendering. */
    private final ReadOnlyListWrapper<DataPoint> combinedDataPoints = new ReadOnlyListWrapper<>(FXCollections.observableArrayList());

    /** A read-only list of the calculated gammas for drawing on the canvas. */
    private final ReadOnlyListWrapper<Complex> measuresGamma = new ReadOnlyListWrapper<>(FXCollections.observableArrayList());

    // =============================================================================================
    // UI & Mouse Interaction Properties
    // =============================================================================================

    // Mouse info (Raw values)
    public final DoubleProperty mouseReturnLoss = new SimpleDoubleProperty(0);
    public final DoubleProperty mouseVSWR = new SimpleDoubleProperty(0);
    public final DoubleProperty mouseQualityFactor = new SimpleDoubleProperty(0);
    public final ObjectProperty<Complex> mouseGamma = new SimpleObjectProperty<>(new Complex(0.0, 0.0));
    public final ObjectProperty<Complex> mouseAdmittanceY = new SimpleObjectProperty<>(new Complex(0.0, 0.0));
    public final ObjectProperty<Complex> mouseImpedanceZ = new SimpleObjectProperty<>(new Complex(0.0, 0.0));

    // Formatted Text Wrappers for UI Binding
    private final ReadOnlyStringWrapper frequencyText = new ReadOnlyStringWrapper("-");
    private final ReadOnlyStringWrapper pulseFrequencyText = new ReadOnlyStringWrapper("-");
    private final ReadOnlyStringWrapper zoText = new ReadOnlyStringWrapper("-");
    private final ReadOnlyStringWrapper mouseReturnLossText = new ReadOnlyStringWrapper("- dB");
    private final ReadOnlyStringWrapper mouseVSWRText = new ReadOnlyStringWrapper("-");
    private final ReadOnlyStringWrapper mouseQualityFactorText = new ReadOnlyStringWrapper("-");
    private final ReadOnlyStringWrapper mouseGammaText = new ReadOnlyStringWrapper("-");
    private final ReadOnlyStringWrapper mouseAdmittanceYText = new ReadOnlyStringWrapper("Y: -");
    private final ReadOnlyStringWrapper mouseImpedanceZText = new ReadOnlyStringWrapper("Z: -");

    // Cursor & Selection
    public final ObjectProperty<Complex> ghostCursorGamma = new SimpleObjectProperty<>();
    public final BooleanProperty showGhostCursor = new SimpleBooleanProperty(false);
    private final IntegerProperty dpTableSelIndex = new SimpleIntegerProperty(-1); // Selected row in data table

    private final ObjectProperty<CircuitElement> hoveredElement = new SimpleObjectProperty<>();
    private final IntegerProperty selectedInsertionIndex = new SimpleIntegerProperty(0); // 0 will select the only position
    private final ObjectProperty<CircuitElement> selectedElement = new SimpleObjectProperty<>();

    // Previews
    private final ObjectProperty<CircuitElement> previewElement = new SimpleObjectProperty<>();
    private final ObjectProperty<CircuitElement> previewElementS1P = new SimpleObjectProperty<>();
    private final ReadOnlyListWrapper<DataPoint> previewTransformedS1PPoints = new ReadOnlyListWrapper<>(FXCollections.observableArrayList());

    // Display Options
    private final ReadOnlyListWrapper<Double> vswrCircles = new ReadOnlyListWrapper<>(FXCollections.observableArrayList());
    private final ReadOnlyDoubleWrapper s1pPointSize = new ReadOnlyDoubleWrapper(4.0);
    private boolean showSweepInDataPoints = false;
    private boolean showS1PInDataPoints = false;

    // =============================================================================================
    // Application State (Project, Undo/Redo, Modification)
    // =============================================================================================

    private final StringProperty projectName = new SimpleStringProperty("Untitled");
    private final BooleanProperty hasBeenSaved = new SimpleBooleanProperty(false);
    private final BooleanProperty isModified = new SimpleBooleanProperty(false);
    public BooleanProperty isModifyingComponent = new SimpleBooleanProperty(false);

    // State preservation for cancellation
    private Pair<Integer, CircuitElement> originalElement;
    private boolean suppressModificationEvents = true;

    // Memory property for the characteristic impedance switching
    private double savedFrequency = -1; //-1 means no saved state
    private Complex savedLoadImpedance;

    // =============================================================================================
    // Advanced Configuration (Filters, S1P Load, Discrete, Q-Factor)
    // =============================================================================================

    // S1P Load option for each filters
    private final BooleanProperty useS1PAsLoadF1 = new SimpleBooleanProperty(false);
    private final BooleanProperty useS1PAsLoadF2 = new SimpleBooleanProperty(false);
    private final BooleanProperty useS1PAsLoadF3 = new SimpleBooleanProperty(false);
    private final BooleanProperty filter1Enabled = new SimpleBooleanProperty(true);
    private final BooleanProperty filter2Enabled = new SimpleBooleanProperty(false);
    private final BooleanProperty filter3Enabled = new SimpleBooleanProperty(false);

    // RangeSlider private properties
    private double freqRangeMinF1, freqRangeMaxF1;
    private double freqRangeMinF2, freqRangeMaxF2;
    private double freqRangeMinF3, freqRangeMaxF3;

    // Quality factor stuff
    private final BooleanProperty isUsingQualityFactor = new SimpleBooleanProperty(false);

    // Discrete component handling
    private final SimpleListProperty<ComponentEntry> discreteComponentConfig = new SimpleListProperty<>(FXCollections.observableArrayList());
    private final BooleanProperty isUsingDiscreteComponents = new SimpleBooleanProperty(false);

    // Mouse load input var
    private final BooleanProperty isSettingLoadInputByMouse = new SimpleBooleanProperty(false);

    // Sweep Configuration
    private double currentSweepMin = 1e6;
    private double currentSweepMax = 100e6;
    private int currentSweepCount = 10;

    // =============================================================================================
    // Constructor & Initialization
    // =============================================================================================

    private SmithChartViewModel() {
        // Initialize with one default circuit containing the extractor for updates
        addCircuit();

        // Bind the active circuit property to the selected index
        circuitElements.bind(Bindings.valueAt(allCircuits, circuitElementIndex));

        // Cancel any modification in progress when switching circuits
        circuitElementIndex.addListener(_ -> cancelTuningAdjustments());

        allCircuits.addListener((ListChangeListener<? super ObservableList<CircuitElement>>) _ -> {

            // If circuits are removed while modifying, cancel it to avoid issues
            cancelTuningAdjustments();
        });

        // When any sources change, trigger a full recalculation.
        zo.addListener((_, _, _) -> {
            zoText.set(zo.get() + " Ω");
            recalculateImpedanceChain();
            markAsModified();
        });
        frequency.addListener((_, _, _) -> {
            //Update the display for frequency
            double freq = frequency.get();
            String newFreqText = SmithUtilities.displayBestUnitAndFormattedValue(freq, FrequencyUnit.values());
            frequencyText.set(newFreqText);
            pulseFrequencyText.set(String.format("%.2e rad/s", 2 * Math.PI * freq));
            recalculateImpedanceChain();
            markAsModified();
        });

        circuitElements.addListener((ListChangeListener<CircuitElement>) change -> {
            while (change.next()) {
                if (change.wasUpdated()) {
                    recalculateImpedanceChain();
                    // Sweep is handled within recalculateImpedanceChain (delegated below)
                    markAsModified();
                }
                if (change.wasAdded() || change.wasRemoved()) {
                    recalculateImpedanceChain();
                    markAsModified();
                }
            }
        });

        //Set the initial frequency at 1GHz
        frequency.set(1e9);
        //Set the characteristic impedance to 50 Ohm
        zo.set(50.0);
        //Set a dummy impedance value
        loadImpedance.set(new Complex(zo.get() * 2, zo.get() * 3));

        loadImpedance.addListener((_, _, _) -> {
            recalculateImpedanceChain();
            markAsModified();
        });

        // When the list of derived impedances changes, automatically update the gamma values.
        dataPoints.addListener((ListChangeListener<DataPoint>) _ -> {
            if (isAnyUseS1PAsLoad()) recalculateS1PChain();
            recalculateAllGammas();
        });

        s1pDataPoints.addListener((ListChangeListener<DataPoint>) _ -> {
            recalculateS1PChain();
            markAsModified();
        });

        previewElementS1P.addListener((_, _, _) -> {
            if (previewElementS1P.get() == null) {
                previewTransformedS1PPoints.clear();
                cachedS1PPoints.clear();
                return;
            }
            recalculateS1PChain();
        });

        // Listen for changes in the main data points and update combined points
        dataPoints.addListener((ListChangeListener<DataPoint>) _ -> updateCombinedDataPoints());
        s1pDataPoints.addListener((ListChangeListener<DataPoint>) _ -> updateCombinedDataPoints());
        sweepDataPoints.addListener((ListChangeListener<DataPoint>) _ -> updateCombinedDataPoints());

        // Perform the initial calculation when the view model is created.
        recalculateImpedanceChain();

        suppressModificationEvents = false;
    }

    /**
     * Singleton instance accessor.
     * @return The single instance of SmithChartViewModel.
     */
    public static SmithChartViewModel getInstance() {
        return Holder.INSTANCE;
    }

    // =============================================================================================
    // Core Calculation Logic (Delegated)
    // =============================================================================================

    /**
     * Delegates the main circuit calculation to the Simulator Service.
     * Also triggers S1P and Sweep updates.
     */
    private void recalculateImpedanceChain() {
        Complex currentImpedance = loadImpedance.get();
        if (currentImpedance == null) return;

        // Calculate Main Chain
        List<DataPoint> mainPoints = simulator.calculateChain(
                loadImpedance.get(),
                frequency.get(),
                zo.get(),
                circuitElements.get()
        );
        dataPoints.setAll(mainPoints);

        // Trigger Secondary Calculations
        recalculateS1PChain();
        performFrequencySweep();
    }

    /**
     * Delegates S1P transformation to the Simulator Service.
     */
    private void recalculateS1PChain() {
        if (!isAnyUseS1PAsLoad() || s1pDataPoints.isEmpty()) {
            transformedS1PPoints.clear();
            if (!isAnyUseS1PAsLoad()) transformedS1PPoints.setAll(s1pDataPoints);
            cachedS1PPoints.clear();
            return;
        }

        boolean isPreviewing = previewElementS1P.get() != null && !isModifyingComponent.get();

        // Select Data Source (Cache vs Original)
        List<DataPoint> sourcePoints = (isPreviewing && !cachedS1PPoints.isEmpty()) ?
                cachedS1PPoints : s1pDataPoints;

        // Select Elements (All vs Preview Only)
        List<CircuitElement> elementsToApply = isPreviewing ?
                List.of(previewElementS1P.get()) : circuitElements.get();

        // Calculate
        List<DataPoint> newTransformedPoints = simulator.calculateTransformedS1P(
                sourcePoints, elementsToApply, zo.get()
        );

        transformedS1PPoints.setAll(newTransformedPoints);

        // Update cache only if not previewing (means we added a new component/changed baseline)
        if (!isPreviewing) {
            cachedS1PPoints.clear();
            cachedS1PPoints.addAll(newTransformedPoints);
        }
    }

    /**
     * Updates the UI-bound properties based on the mouse cursor position on the chart.
     * Delegates math to SmithCalculator.
     *
     * @param gammaX The X component of Gamma (Real part).
     * @param gammaY The Y component of Gamma (Imaginary part).
     */
    public void calculateMouseInformations(double gammaX, double gammaY) {
        Complex gamma = new Complex(gammaX, gammaY);
        this.mouseGamma.set(gamma);

        // Only perform calculations for points within the Smith Chart (|Gamma| <= 1)
        if (gamma.magnitude() > 1.0) {
            setMouseInfoToDefault();
            return;
        }

        // Use SmithCalculator for transformations
        // Z = Gamma -> Impedance
        Complex impedanceZ = SmithCalculator.gammaToImpedance(gamma, zo.get());

        // Handle singularity (Gamma ~ 1)
        if (impedanceZ.real() > 1e9) { // Extremely high resistance
            setMouseInfoToOpenCircuit(gamma);
            return;
        }

        Complex admittanceY = impedanceZ.inverse();

        // Calculate derived RF values
        double returnLoss = (gamma.magnitude() < 1e-9) ? Double.POSITIVE_INFINITY : -20 * Math.log10(gamma.magnitude());
        double vswr = (gamma.magnitude() < 1e-9) ? Double.POSITIVE_INFINITY : (1 + gamma.magnitude()) / (1 - gamma.magnitude());
        double qFactor = (impedanceZ.real() < 1e-9) ? Double.POSITIVE_INFINITY : Math.abs(impedanceZ.imag()) / impedanceZ.real();

        //Update properties
        mouseReturnLoss.set(returnLoss);
        mouseVSWR.set(vswr);
        mouseImpedanceZ.set(impedanceZ);
        mouseAdmittanceY.set(admittanceY);
        mouseQualityFactor.set(qFactor);

        //Format strings for controller
        mouseReturnLossText.set(String.format("%.3f dB", returnLoss));
        mouseVSWRText.set(String.format("%.3f", vswr));
        mouseGammaText.set(String.format("%.3f ∠ %.3f°", gamma.magnitude(), Math.toDegrees(gamma.angle())));
        mouseImpedanceZText.set(impedanceZ.toString());
        mouseAdmittanceYText.set(admittanceY.toStringmS());
        mouseQualityFactorText.set(String.format("%.3f", qFactor));
    }

    private void setMouseInfoToDefault() {
        mouseReturnLossText.set("- dB");
        mouseVSWRText.set("∞");
        mouseQualityFactorText.set("-");
        mouseGammaText.set("-");
        mouseAdmittanceYText.set("-");
        mouseImpedanceZText.set("-");
    }

    private void setMouseInfoToOpenCircuit(Complex gamma) {
        mouseReturnLossText.set("0.00 dB");
        mouseVSWRText.set("∞");
        mouseQualityFactorText.set("∞");
        mouseGammaText.set(String.format("%.3f ∠ %.3f°", gamma.magnitude(), Math.toDegrees(gamma.angle())));
        mouseAdmittanceYText.set("0.00 + j0.00 mS");
        mouseImpedanceZText.set("∞");
    }

    /**
     * Converts the entire measures list (impedance) into the measuresGamma list (reflection coefficients).
     */
    private void recalculateAllGammas() {
        List<Complex> newGammas = dataPoints.stream()
                .map(dp -> dp.gammaProperty().get())
                .collect(Collectors.toList());
        measuresGamma.setAll(newGammas);
    }

    private void updateCombinedDataPoints() {
        var combined = FXCollections.observableArrayList(dataPoints);
        if (showS1PInDataPoints) combined.addAll(s1pDataPoints);
        if (showSweepInDataPoints) combined.addAll(sweepDataPoints);
        combinedDataPoints.setAll(combined);
    }

    // =============================================================================================
    // Circuit Modification Methods (Add, Remove, Tune)
    // =============================================================================================

    /**
     * Adds a new empty circuit tab.
     */
    public void addCircuit(){
        allCircuits.add(FXCollections.observableArrayList(
                element -> new javafx.beans.Observable[]{ element.realWorldValueProperty() }
        ));
        circuitElementIndex.set(allCircuits.size() -1);
    }

    /**
     * Switches to the circuit at the specified index.
     * If the index is out of bounds, no action is taken.
     * @param index The index of the circuit to switch to.
     */
    public void chooseCircuit(int index){
        if(index >=0 && index < allCircuits.size()){
            circuitElementIndex.set(index);
        } // else nothing ever happens
    }

    /**
     * Adds a new component to the circuit and triggers a full recalculation.
     */
    public void addComponent(CircuitElement.ElementType type, double value, CircuitElement.ElementPosition position, Optional<Double> qualityFactor) {
        addComponent(type, value, 0.0, 0.0, position, qualityFactor, null);
    }

    /**
     * Adds a new component to the circuit (detailed version).
     * Uses HistoryManager to record the action.
     */
    public void addComponent(CircuitElement.ElementType type, double value, double characteristicImpedance, double permittivity, CircuitElement.ElementPosition position, Optional<Double> qualityFactor, Line.StubType stubType) {
        CircuitElement newElem = switch (type) {
            case INDUCTOR -> new Inductor(value, position, type);
            case CAPACITOR -> new Capacitor(value, position, type);
            case RESISTOR -> new Resistor(value, position, type);
            case LINE -> {
                if (stubType == null || stubType == Line.StubType.NONE) {
                    yield new Line(value, characteristicImpedance, permittivity);
                } else {
                    yield new Line(value, characteristicImpedance, permittivity, stubType);
                }
            }
        };

        if (isUsingQualityFactor.get() && qualityFactor.isPresent()) newElem.setQualityFactor(qualityFactor.get());

        int index;

        if (isModifyingComponent.get() && selectedElement.get() != null) {
            // Modification Case
            index = circuitElements.indexOf(selectedElement.get());
            if (index == -1) return;

            CircuitElement oldElem = circuitElements.get(index);
            circuitElements.set(index, newElem);
            historyManager.push(new UndoRedoEntry(Operation.MODIFY, index, new Pair<>(circuitElementIndex.get(),oldElem))); // Save old state for undo
        } else {
            // Addition Case
            if (selectedInsertionIndex.get() >= 0 && selectedInsertionIndex.get() <= circuitElements.size()) {
                index = selectedInsertionIndex.get();
            } else {
                index = circuitElements.size();
            }
            circuitElements.add(index, newElem);
            historyManager.push(new UndoRedoEntry(Operation.ADD, index, new Pair<>(circuitElementIndex.get(),newElem)));
        }

        selectedElement.set(null);
        selectedInsertionIndex.set(circuitElements.size());
        recalculateImpedanceChain();
    }

    /**
     * Remove the component using their index number.
     */
    void removeComponentAt(int index) {
        try {
            if (index < 0 || index >= circuitElements.size()) return;

            CircuitElement removed = circuitElements.get(index);
            circuitElements.remove(index);

            if (isModifyingComponent.get() && selectedElement.get() != null) {
                if (removed == selectedElement.get()) selectedElement.set(null);
            }

            historyManager.push(new UndoRedoEntry(Operation.REMOVE, index, new Pair<>(circuitElementIndex.get(),removed)));
            recalculateImpedanceChain();
        } catch (ArrayIndexOutOfBoundsException e) {
            Logger.getLogger("Error").log(Level.SEVERE, e.getMessage());
        }
    }

    public void removeComponent(CircuitElement element) {
        int index = circuitElements.indexOf(element);
        if (index != -1) removeComponentAt(index);
    }

    /**
     * Sets the element to be modified.
     */
    public void selectElement(CircuitElement element) {
        if (selectedElement.get() != null) {
            cancelTuningAdjustments();
        }

        if (element != null && circuitElements.contains(element)) {
            selectedElement.set(element);
            originalElement = new Pair<>(circuitElementIndex.get(), element.copy()); // Save the state BEFORE tuning starts
        } else {
            selectedElement.set(null);
        }
    }

    /**
     * Called by the Slider in the View to update the value live.
     */
    public void updateTunedElementValue(double newValue) {
        updateTunedElementValue(newValue, null, null, null, Optional.empty(), Optional.empty(), Optional.empty());
    }

    /**
     * Called by the View when modifying a component to update type/position/value live.
     * Note: This logic recreates objects if types change, which is why it's kept in ViewModel
     * rather than delegated to a purely stateless service.
     */
    public void updateTunedElementValue(double newValue, CircuitElement.ElementType elementType, CircuitElement.ElementPosition elementPosition, Line.StubType stubType, Optional<Double> permittivity, Optional<Double> z0Line, Optional<Double> qualityFactor) {
        CircuitElement current = selectedElement.get();

        if (current != null) {
            int index = circuitElements.indexOf(current);
            if (index == -1) return;

            // Check if Type changed OR if it's a Line and the StubType changed
            boolean typeChanged = (elementType != null && elementType != current.getType());
            boolean stubChanged = false;

            if (current instanceof Line line && stubType != null) {
                stubChanged = (line.getStubType() != stubType);
            }

            // Recreate logic (similar to addComponent factory logic)
            if (typeChanged || stubChanged) {
                CircuitElement newElement = switch (elementType) {
                    case INDUCTOR -> new Inductor(newValue, current.getElementPosition(), elementType);
                    case CAPACITOR -> new Capacitor(newValue, current.getElementPosition(), elementType);
                    case RESISTOR -> new Resistor(newValue, current.getElementPosition(), elementType);
                    case LINE -> {
                        if (z0Line.isEmpty() || permittivity.isEmpty()) yield null;
                        if (stubType == null || stubType == Line.StubType.NONE) {
                            yield new Line(newValue, z0Line.get(), permittivity.get());
                        } else {
                            yield new Line(newValue, z0Line.get(), permittivity.get(), stubType);
                        }
                    }
                };

                if (newElement != null) {
                    circuitElements.set(index, newElement);
                    selectedElement.set(newElement);
                    current = newElement;
                }
            }

            if (current == null) return;

            if (elementPosition != null && current.getType() != CircuitElement.ElementType.LINE) {
                current.setPosition(elementPosition);
            }

            if (current instanceof Line line) {
                if (stubType != null) line.setStubType(stubType);
                permittivity.ifPresent(line::setPermittivity);
                z0Line.ifPresent(line::setCharacteristicImpedance);
            }

            if (isUsingQualityFactor.get() && qualityFactor.isPresent()) {
                current.setQualityFactor(qualityFactor.get());
            }

            current.setRealWorldValue(newValue);
        }
    }

    /**
     * User clicked "Apply". We commit the change.
     */
    public void applyTuningAdjustments() {
        if (selectedElement.get() == null) return;

        int index = circuitElements.indexOf(selectedElement.get());
        selectedElement.set(null);
        // Push the ORIGINAL element to undo stack (so undo reverts to pre-modification)
        historyManager.push(new UndoRedoEntry(Operation.MODIFY, index, new Pair<>(originalElement.getKey(), originalElement.getValue().copy())));
    }

    /**
     * User clicked "Cancel". We revert the value.
     */
    public void cancelTuningAdjustments() {
        CircuitElement current = selectedElement.get();

        // Check if we have a stored original state
        if (current != null && originalElement != null) {
            int originalCircuitIndex = originalElement.getKey();

            // Safety check: Does this circuit still exist?
            if (originalCircuitIndex < allCircuits.size()) {
                ObservableList<CircuitElement> targetList = allCircuits.get(originalCircuitIndex);

                int index = targetList.indexOf(current);

                // Only proceed if we found the element in that specific circuit
                if (index != -1) {
                    targetList.set(index, originalElement.getValue());

                    // Only trigger recalculation if we just reverted the ACTIVE circuit.
                    if (circuitElementIndex.get() == originalCircuitIndex) {
                        recalculateImpedanceChain();
                    }
                }
            }
        }
        selectedElement.set(null);
        originalElement = null;
    }

    /**
     * Undo logic delegated to HistoryManager
     */
    public void undo() {
        historyManager.popUndo().ifPresent(entry -> processUndoRedo(entry, true));
    }

    /**
     * Redo logic delegated to HistoryManager
     */
    public void redo() {
        historyManager.popRedo().ifPresent(entry -> processUndoRedo(entry, false));
    }

    /**
     * Processes an Undo/Redo entry retrieved from the HistoryManager.
     */
    private void processUndoRedo(UndoRedoEntry entry, boolean isUndo) {

        int targetCircuitIndex = entry.element.getKey();
        if (circuitElementIndex.get() != targetCircuitIndex) {
            circuitElementIndex.set(targetCircuitIndex);
        }

        cancelTuningAdjustments(); // Ensure clean state

        if (entry.operation == Operation.MODIFY) {
            if (entry.index < circuitElements.size()) {
                // Capture the current state (which is about to be overwritten)
                CircuitElement currentElem = circuitElements.get(entry.index);

                // Apply the restoration (entry.element holds the state we are moving TO)
                allCircuits.get(entry.element.getKey()).set(entry.index, entry.element.getValue());

                // Prepare the inverse entry for the opposite stack.
                // If we just Undid (restored Old), we need to save New for Redo.
                // If we just Redid (restored New), we need to save Old for Undo.
                UndoRedoEntry inverseEntry = new UndoRedoEntry(Operation.MODIFY, entry.index, new Pair<>(circuitElementIndex.get(),currentElem));

                if (isUndo) {
                    historyManager.pushRedo(inverseEntry);
                } else {
                    // Use pushUndo to avoid clearing the redo stack
                    historyManager.pushUndo(inverseEntry);
                }
            }
        } else {
            // ADD / REMOVE Logic
            boolean shouldAdd;
            if (entry.operation == Operation.ADD) {
                shouldAdd = !isUndo; // Undo Add = Remove
            } else { // Operation.REMOVE
                shouldAdd = isUndo;  // Undo Remove = Add
            }

            if (shouldAdd) {
                allCircuits.get(entry.element.getKey()).set(entry.index, entry.element.getValue());
            } else {
                allCircuits.get(entry.element.getKey()).remove(entry.index);
            }

            // Push the inverse operation to the opposite stack
            if (isUndo) {
                historyManager.pushRedo(entry);
            } else {
                historyManager.pushUndo(entry);
            }
        }

        recalculateImpedanceChain();
    }


    // =============================================================================================
    // S1P & Sweep Operations
    // =============================================================================================

    public void addS1PDatapoints(List<DataPoint> dp) {
        s1pDataPoints.setAll(dp);
    }

    public void clearS1PDatapoints() {
        s1pDataPoints.clear();
    }

    public void clearSweepPoints() {
        sweepDataPoints.clear();
        pointToSweep.clear();
    }

    public void exportSweepToS1P(File file, String fileName) {
        if (sweepDataPoints.isEmpty()) return;

        File outputFile = file;
        if (outputFile.isDirectory()) {
            outputFile = new File(outputFile, fileName + ".s1p");
        }

        int indexToTake = sweepDataPoints.getSize() / 2;
        FrequencyUnit frequencyUnit = (FrequencyUnit) SmithUtilities.getBestUnitAndFormattedValue(
                sweepDataPoints.get(indexToTake).getFrequency(), FrequencyUnit.values()
        ).getKey();

        try {
            // Delegated to TouchstoneS1P service
            TouchstoneS1P.export(sweepDataPoints, zo.get(), frequencyUnit, outputFile);
        } catch (Exception e) {
            Logger.getLogger("Error").log(Level.SEVERE, "Error exporting sweep to S1P: " + e.getMessage());
        }
    }

    private void performFrequencySweep() {
        performFrequencySweep(new ArrayList<>(pointToSweep));
    }

    public void performFrequencySweep(List<Double> frequencies) {
        if (frequencies.isEmpty()) return;

        frequencies.sort(Double::compareTo);
        this.currentSweepMin = frequencies.getFirst();
        this.currentSweepMax = frequencies.getLast();
        this.currentSweepCount = frequencies.size();
        this.pointToSweep.setAll(frequencies);

        List<DataPoint> results = simulator.performSweep(
                loadImpedance.get(),
                frequencies,
                circuitElements.get(),
                zo.get()
        );
        sweepDataPoints.setAll(results);
    }

    public void updateSweepConfiguration(double minFreq, double maxFreq, int count) {
        if (minFreq >= maxFreq || count < 2) return;

        this.currentSweepMin = minFreq;
        this.currentSweepMax = maxFreq;
        this.currentSweepCount = count;

        List<Double> frequencies = new ArrayList<>();
        double step = (maxFreq - minFreq) / (count - 1);

        for (int i = 0; i < count; i++) {
            frequencies.add(minFreq + (i * step));
        }

        performFrequencySweep(frequencies);
    }

    public void incrementSweepStartFrequency() {
        double newMin = currentSweepMin * 1.05;
        if (newMin < currentSweepMax) updateSweepConfiguration(newMin, currentSweepMax, currentSweepCount);
    }

    public void decrementSweepStartFrequency() {
        updateSweepConfiguration(currentSweepMin * 0.95, currentSweepMax, currentSweepCount);
    }

    public void incrementSweepEndFrequency() {
        updateSweepConfiguration(currentSweepMin, currentSweepMax * 1.05, currentSweepCount);
    }

    public void decrementSweepEndFrequency() {
        double newMax = currentSweepMax * 0.95;
        if (newMax > currentSweepMin) updateSweepConfiguration(currentSweepMin, newMax, currentSweepCount);
    }

    // =============================================================================================
    // Preview & Live Calculation
    // =============================================================================================

    public void addLiveComponentPreview(Double liveValue, double z0Line, double permittivity, Line.StubType stubType, Optional<Double> qualityFactor) {
        Line newLine;
        if (stubType == null || stubType == Line.StubType.NONE) {
            if (isShowS1PAsLoad()) previewElementS1P.set(new Line(liveValue, z0Line, permittivity));
            newLine = new Line(liveValue, z0Line, permittivity);

        } else {
            if (isShowS1PAsLoad()) previewElementS1P.set(new Line(liveValue, z0Line, permittivity, stubType));
            newLine = new Line(liveValue, z0Line, permittivity, stubType);
        }
        qualityFactor.ifPresent(newLine::setQualityFactor);
        previewElement.set(newLine);
    }

    public void addLiveComponentPreview(CircuitElement.ElementType type, Double liveValue, CircuitElement.ElementPosition position, Optional<Double> qualityFactor) {
        CircuitElement element = switch (type) {
            case INDUCTOR -> new Inductor(liveValue, position, type);
            case CAPACITOR -> new Capacitor(liveValue, position, type);
            case RESISTOR -> new Resistor(liveValue, position, type);
            default -> null;
        };
        if (element != null) qualityFactor.ifPresent(element::setQualityFactor);
        if (isShowS1PAsLoad()) previewElementS1P.set(element);
        previewElement.set(element);
    }

    public void clearLiveComponentPreview() {
        previewElementS1P.set(null);
        previewElement.set(null);
        cachedS1PPoints.clear();
        recalculateS1PChain();
    }

    public Complex getPreviewElementGamma() {
        CircuitElement preview = previewElement.get();
        if (preview == null) return null;

        Complex currentImpedance = getCurrentInteractionStartImpedance();
        if (currentImpedance == null) return null;

        // Calculate single step using helper logic (inlined here or could be in simulator)
        Complex finalImpedance;
        if (preview.getType() == CircuitElement.ElementType.LINE) {
            finalImpedance = ((Line) preview).calculateImpedance(currentImpedance, frequency.get());
        } else {
            Complex elementImpedance = preview.getImpedance(frequency.get());
            // Using SmithCalculator helper for combining impedances
            if (preview.getElementPosition() == CircuitElement.ElementPosition.SERIES) {
                finalImpedance = currentImpedance.add(elementImpedance);
            } else {
                finalImpedance = SmithCalculator.addParallelImpedance(currentImpedance, elementImpedance);
            }
        }

        return SmithCalculator.impedanceToGamma(finalImpedance, zo.get());
    }

    public List<Complex> getProjectedGammas() {
        // Logic remains in ViewModel as it depends heavily on the 'selectedInsertionIndex' state
        // and iterates over the specific ViewModel list.
        CircuitElement preview = previewElement.get();
        if (preview == null) return new ArrayList<>();

        List<Complex> projectedGammas = new ArrayList<>();
        int insertIndex = selectedInsertionIndex.get();
        List<CircuitElement> elements = circuitElements.get();

        if (insertIndex < 0 || insertIndex >= elements.size()) return projectedGammas;

        double freq = frequency.get();
        Complex currentImpedance = getCurrentInteractionStartImpedance();

        // Apply preview
        if (preview.getType() == CircuitElement.ElementType.LINE) {
            currentImpedance = ((Line) preview).calculateImpedance(currentImpedance, freq);
        } else {
            Complex elementImpedance = preview.getImpedance(freq);
            if (preview.getElementPosition() == CircuitElement.ElementPosition.SERIES)
                currentImpedance = currentImpedance.add(elementImpedance);
            else
                currentImpedance = SmithCalculator.addParallelImpedance(currentImpedance, elementImpedance);
        }

        // Propagate rest of chain
        for (int i = insertIndex; i < elements.size(); i++) {
            CircuitElement existingElement = elements.get(i);
            if (existingElement.getType() == CircuitElement.ElementType.LINE) {
                currentImpedance = ((Line) existingElement).calculateImpedance(currentImpedance, freq);
            } else {
                Complex elementImpedance = existingElement.getImpedance(freq);
                if (existingElement.getElementPosition() == CircuitElement.ElementPosition.SERIES)
                    currentImpedance = currentImpedance.add(elementImpedance);
                else
                    currentImpedance = SmithCalculator.addParallelImpedance(currentImpedance, elementImpedance);
            }
            projectedGammas.add(SmithCalculator.impedanceToGamma(currentImpedance, zo.get()));
        }

        return projectedGammas;
    }

    /**
     * Helper function to calculate the resulting impedance after adding a new component.
     */
    private Complex calculateNextImpedance(Complex previousImpedance, Complex impedanceToAdd, CircuitElement.ElementPosition position) {
        if (previousImpedance == null || impedanceToAdd == null) return null;
        if (position == CircuitElement.ElementPosition.SERIES) {
            return previousImpedance.add(impedanceToAdd);
        } else {
            return SmithCalculator.addParallelImpedance(previousImpedance, impedanceToAdd);
        }
    }

    private Complex propagateThroughElements(Complex startImpedance, double freq, List<CircuitElement> elements) {
        Complex currentImpedance = startImpedance;
        for (CircuitElement element : elements) {
            if (element.getType() == CircuitElement.ElementType.LINE) {
                currentImpedance = ((Line) element).calculateImpedance(currentImpedance, freq);
            } else {
                Complex elementImpedance = element.getImpedance(freq);
                currentImpedance = calculateNextImpedance(currentImpedance, elementImpedance, element.getElementPosition());
            }
        }
        return currentImpedance;
    }

    // =============================================================================================
    // Property Getters & Setters
    // =============================================================================================

    public ReadOnlyDoubleProperty frequencyProperty() { return frequency; }
    public void setFrequency(Double newFreq) { this.frequency.set(newFreq); }
    public ReadOnlyStringProperty frequencyTextProperty() { return frequencyText.getReadOnlyProperty(); }
    public ReadOnlyStringProperty pulseFrequencyTextProperty() { return pulseFrequencyText.getReadOnlyProperty(); }
    public ReadOnlyStringProperty zoProperty() { return zoText.getReadOnlyProperty(); }
    public ReadOnlyListProperty<DataPoint> dataPointsProperty() { return combinedDataPoints.getReadOnlyProperty(); }
    public ReadOnlyListProperty<DataPoint> sweepDataPointsProperty() { return sweepDataPoints.getReadOnlyProperty(); }
    public ReadOnlyListProperty<DataPoint> s1pDataPointsProperty() { return s1pDataPoints.getReadOnlyProperty(); }
    public ReadOnlyListProperty<DataPoint> transformedS1PPointsProperty() { return transformedS1PPoints.getReadOnlyProperty(); }
    public ReadOnlyListProperty<DataPoint> previewTransformedS1PPointsProperty() { return previewTransformedS1PPoints.getReadOnlyProperty(); }
    public ReadOnlyListProperty<Complex> measuresGammaProperty() { return measuresGamma.getReadOnlyProperty(); }
    public ReadOnlyObjectProperty<CircuitElement> selectedElementProperty() { return selectedElement; }
    public ReadOnlyObjectProperty<CircuitElement> hoveredElementProperty() { return hoveredElement; }
    public void setHoveredElement(CircuitElement hoveredElement) { this.hoveredElement.set(hoveredElement); }
    public ReadOnlyObjectProperty<CircuitElement> previewElementProperty() { return previewElement; }
    public ReadOnlyObjectProperty<CircuitElement> previewElementS1PProperty() { return previewElementS1P; }
    public ReadOnlyIntegerProperty getSelectedInsertionIndexProperty() { return selectedInsertionIndex; }
    public void setSelectedInsertionIndex(int index) { this.selectedInsertionIndex.set(index); }
    public ReadOnlyIntegerProperty getDpTableSelIndex() { return dpTableSelIndex; }
    public void setDpTableSelIndex(int dpTableSelIndex) { this.dpTableSelIndex.set(dpTableSelIndex); }

    public Complex getLastGamma() {
        if (dataPoints.isEmpty()) return null;
        return dataPoints.getLast().gammaProperty().get();
    }

    public Complex getLastImpedance() {
        if (dataPoints.isEmpty()) return null;
        return dataPoints.getLast().impedanceProperty().get();
    }

    public DataPoint getLastDataPoint() {
        if (dataPoints.isEmpty()) return null;
        return dataPoints.getLast();
    }

    public Complex getCurrentInteractionStartImpedance() {
        if (isModifyingComponent.get() && selectedElement.get() != null) {
            int index = circuitElements.indexOf(selectedElement.get());
            if (index != -1 && index < dataPoints.size()) {
                return dataPoints.get(index).impedanceProperty().get();
            }
        } else if (selectedInsertionIndex.get() >= 0 && selectedInsertionIndex.get() < dataPoints.size()) {
            return dataPoints.get(selectedInsertionIndex.get()).impedanceProperty().get();
        }
        return getLastImpedance();
    }

    public Complex getCurrentInteractionStartGamma() {
        if (isModifyingComponent.get() && selectedElement.get() != null) {
            int index = circuitElements.indexOf(selectedElement.get());
            if (index != -1 && index < dataPoints.size()) {
                return dataPoints.get(index).gammaProperty().get();
            }
        } else if (selectedInsertionIndex.get() >= 0 && selectedInsertionIndex.get() < dataPoints.size()) {
            return dataPoints.get(selectedInsertionIndex.get()).gammaProperty().get();
        }
        return getLastGamma();
    }

    // UI Binding Getters
    public ReadOnlyStringProperty mouseReturnLossTextProperty() { return mouseReturnLossText.getReadOnlyProperty(); }
    public ReadOnlyStringProperty mouseVSWRTextProperty() { return mouseVSWRText.getReadOnlyProperty(); }
    public ReadOnlyStringProperty mouseQualityFactorTextProperty() { return mouseQualityFactorText.getReadOnlyProperty(); }
    public ReadOnlyStringProperty mouseGammaTextProperty() { return mouseGammaText.getReadOnlyProperty(); }
    public ReadOnlyStringProperty mouseAdmittanceYTextProperty() { return mouseAdmittanceYText.getReadOnlyProperty(); }
    public ReadOnlyStringProperty mouseImpedanceZTextProperty() { return mouseImpedanceZText.getReadOnlyProperty(); }
    public ReadOnlyListProperty<Double> vswrCirclesProperty() { return vswrCircles.getReadOnlyProperty(); }

    public void setCircleDisplayOptions(List<Double> options) { vswrCircles.setAll(options); }
    public ReadOnlyDoubleProperty s1pPointSizeProperty() { return s1pPointSize.getReadOnlyProperty(); }
    public void setS1PPointSize(double v) { s1pPointSize.set(v); }

    public void setShowSweepDataPoints(boolean selected) {
        if (this.showSweepInDataPoints != selected) {
            this.showSweepInDataPoints = selected;
            updateCombinedDataPoints();
        }
    }

    public void setShowS1PDataPoints(boolean selected) {
        if (this.showS1PInDataPoints != selected) {
            this.showS1PInDataPoints = selected;
            updateCombinedDataPoints();
        }
    }

    // =============================================================================================
    // Configuration & Settings Accessors
    // =============================================================================================

    public BooleanProperty useS1PAsLoadF1Property() { return useS1PAsLoadF1; }
    public BooleanProperty useS1PAsLoadF2Property() { return useS1PAsLoadF2; }
    public BooleanProperty useS1PAsLoadF3Property() { return useS1PAsLoadF3; }
    public BooleanProperty filter1EnabledProperty() { return filter1Enabled; }
    public BooleanProperty filter2EnabledProperty() { return filter2Enabled; }
    public BooleanProperty filter3EnabledProperty() { return filter3Enabled; }
    public ReadOnlyBooleanProperty isUsingQualityFactorProperty() { return isUsingQualityFactor; }
    public void setUseQualityFactor(Boolean newVal) { this.isUsingQualityFactor.set(newVal); }
    public boolean isAnyUseS1PAsLoad() { return useS1PAsLoadF1.get() || useS1PAsLoadF2.get() || useS1PAsLoadF3.get(); }
    public boolean isShowS1PAsLoad() { return isAnyUseS1PAsLoad(); }
    public ReadOnlyListProperty<ComponentEntry> discreteComponentConfigProperty() { return discreteComponentConfig; }
    public void setDiscreteComponentConfig(List<ComponentEntry> config) { this.discreteComponentConfig.set((ObservableList<ComponentEntry>) config); }
    public void setUsingDiscreteComponents(boolean useDiscreteComponents) { isUsingDiscreteComponents.set(useDiscreteComponents); }
    public ReadOnlyBooleanProperty isUsingDiscreteComponentsProperty() { return isUsingDiscreteComponents; }

    public Optional<ComponentEntry> getClosestComponentEntry(double actualValue, CircuitElement.ElementType type) {
        return discreteComponentConfig.stream()
                .filter(e -> e.getType() == type)
                .reduce((closest, current) ->
                        Math.abs(current.getValue() - actualValue) < Math.abs(closest.getValue() - actualValue) ? current : closest
                );
    }

    public List<Complex> getDiscreteComponentGammas() {
        if (discreteComponentConfig.isEmpty() ||
                !isUsingDiscreteComponents.get() ||
                previewElement.get() == null ||
                previewElement.get().getType() == CircuitElement.ElementType.LINE) {
            return null;
        } else {
            List<Complex> gammas = new ArrayList<>();
            for (ComponentEntry entry : discreteComponentConfig) {
                if (entry.getType() != previewElement.get().getType()) continue;

                Complex impedanceToAdd = switch (entry.getType()) {
                    case INDUCTOR -> Inductor.getImpedanceStatic(entry.getValue(), frequency.get(), Optional.of(entry.getQualityFactor(frequencyProperty().get())), previewElement.get().getElementPosition());
                    case CAPACITOR -> Capacitor.getImpedanceStatic(entry.getValue(), frequency.get(), Optional.of(entry.getQualityFactor(frequencyProperty().get())), previewElement.get().getElementPosition());
                    case RESISTOR -> new Complex(entry.getValue(), 0);
                    default -> null;
                };

                if (impedanceToAdd != null) {
                    Complex newImpedance = calculateNextImpedance(getCurrentInteractionStartImpedance(), impedanceToAdd, previewElement.get().getElementPosition());
                    gammas.add(SmithCalculator.impedanceToGamma(newImpedance, zo.get()));
                }
            }
            return gammas;
        }
    }

    public ReadOnlyBooleanProperty isSettingLoadInputByMouseProperty() { return isSettingLoadInputByMouse; }
    public void setLoadInputByMouse(boolean val) { isSettingLoadInputByMouse.set(val); }

    // Project state accessors
    public StringProperty projectNameProperty() { return projectName; }
    public BooleanProperty hasBeenSavedProperty() { return hasBeenSaved; }
    public BooleanProperty isModifiedProperty() { return isModified; }
    public void setProjectName(String name) { this.projectName.set(name); }
    public void setHasBeenSaved(boolean saved) { this.hasBeenSaved.set(saved); }
    public void setIsModified(boolean modified) { this.isModified.set(modified); }
    private final ProjectManager projectManager = new ProjectManager();

    private void markAsModified() {
        if (!suppressModificationEvents && !isModified.get()) {
            isModified.set(true);
        }
    }

    public void resetProject(){
        suppressModificationEvents = true;
        projectName.set("Untitled Project");
        hasBeenSaved.set(false);
        isModified.set(false);
        circuitElements.clear();
        dataPoints.clear();
        measuresGamma.clear();
        s1pDataPoints.clear();
        sweepDataPoints.clear();
        combinedDataPoints.clear();
        selectedElement.set(null);
        selectedInsertionIndex.set(-1);
        historyManager.clear();
        projectManager.resetProject();
        suppressModificationEvents = false;
    }

    public void load(){
        suppressModificationEvents = true;

        FileChooser fc = new FileChooser();
        fc.setTitle("Load a JSMFX Project");
        fc.getExtensionFilters().add(new FileChooser.ExtensionFilter("JSMFX file", "*.jsmfx"));
        File file = fc.showOpenDialog(SmithUtilities.getActiveStage());

        if (file == null) {
            suppressModificationEvents = false;
            return;
        }

        projectManager.loadProject(this, file);
        isModified.set(false);
        suppressModificationEvents = false;
    }

    public void save(){
        suppressModificationEvents = true;
        // Check if the project has ever been saved
        if (!hasBeenSaved.get()) {
            // Create a new project file and let the user choose the location
            FileChooser fc = new FileChooser();
            fc.setTitle("Save your new project !");
            fc.getExtensionFilters().add(new FileChooser.ExtensionFilter("JSMFX file", "*.jsmfx"));
            fc.setInitialFileName(projectName.get() + ".jsmfx");
            File f = fc.showSaveDialog(SmithUtilities.getActiveStage());

            if (f == null) {
                suppressModificationEvents = false;
                return;
            }

            projectManager.saveProject(this, Optional.of(f));
            hasBeenSaved.set(true);
        } else {
            projectManager.saveProject(this, Optional.empty());
        }
        isModified.set(false);
        suppressModificationEvents = false;
    }

    // Frequency Range Filter Helpers
    public void setFrequencyRangeMinF1(double v) { this.freqRangeMinF1 = v; }
    public void setFrequencyRangeMaxF1(double v) { this.freqRangeMaxF1 = v; }
    public void setFrequencyRangeMinF2(double v) { this.freqRangeMinF2 = v; }
    public void setFrequencyRangeMaxF2(double v) { this.freqRangeMaxF2 = v; }
    public void setFrequencyRangeMinF3(double v) { this.freqRangeMinF3 = v; }
    public void setFrequencyRangeMaxF3(double v) { this.freqRangeMaxF3 = v; }

    public boolean isFrequencyInRange(double freq) {
        boolean inF1 = filter1Enabled.get() && isFrequencyInRangeF1(freq);
        boolean inF2 = filter2Enabled.get() && isFrequencyInRangeF2(freq);
        boolean inF3 = filter3Enabled.get() && isFrequencyInRangeF3(freq);
        return inF1 || inF2 || inF3;
    }

    public boolean isFrequencyInRangeF1(double freq) { return freq >= freqRangeMinF1 && freq <= freqRangeMaxF1; }
    public boolean isFrequencyInRangeF2(double freq) { return freq >= freqRangeMinF2 && freq <= freqRangeMaxF2; }
    public boolean isFrequencyInRangeF3(double freq) { return freq >= freqRangeMinF3 && freq <= freqRangeMaxF3; }

    public void setUseS1PAsLoadF1(Boolean newVal) {
        if (newVal == null || newVal == useS1PAsLoadF1.get()) return;
        setUseS1PAsLoad(newVal, 1);
    }

    public void setUseS1PAsLoadF2(Boolean newVal) {
        if (newVal == null || newVal == useS1PAsLoadF2.get()) return;
        setUseS1PAsLoad(newVal, 2);
    }

    public void setUseS1PAsLoadF3(Boolean newVal) {
        if (newVal == null || newVal == useS1PAsLoadF3.get()) return;
        setUseS1PAsLoad(newVal, 3);
    }

    private void setUseS1PAsLoad(Boolean newVal, int filterNumber) {
        switch (filterNumber) {
            case 1: useS1PAsLoadF1.set(newVal); useS1PAsLoadF2.set(false); useS1PAsLoadF3.set(false); break;
            case 2: useS1PAsLoadF1.set(false); useS1PAsLoadF2.set(newVal); useS1PAsLoadF3.set(false); break;
            case 3: useS1PAsLoadF1.set(false); useS1PAsLoadF2.set(false); useS1PAsLoadF3.set(newVal); break;
            default: return;
        }

        if (savedFrequency == -1 && savedLoadImpedance == null) {
            savedFrequency = frequency.get();
            savedLoadImpedance = loadImpedance.get();
        } else if (!isAnyUseS1PAsLoad()) {
            loadImpedance.set(savedLoadImpedance);
            frequency.set(savedFrequency);
            savedFrequency = -1;
            savedLoadImpedance = null;
            return;
        }
        updateMiddleRangePoint();
    }

    public void setS1PLoadValue(Double newValue) {
        if (!isAnyUseS1PAsLoad()) return;
        if (s1pDataPoints.isEmpty()) return;
        DataPoint targetPoint = s1pDataPoints.get(getS1PIndexAtRange(newValue));
        loadImpedance.set(targetPoint.getImpedance());
        frequency.set(targetPoint.getFrequency());
    }

    private int whichFilterIsUsingS1PAsLoad() {
        if (useS1PAsLoadF1.get()) return 1;
        if (useS1PAsLoadF2.get()) return 2;
        if (useS1PAsLoadF3.get()) return 3;
        return -1;
    }

    public void updateMiddleRangePoint() {
        if (!isAnyUseS1PAsLoad() || s1pDataPoints.isEmpty()) return;
        int s1pIndexMin;
        int s1pIndexMax;

        switch (whichFilterIsUsingS1PAsLoad()) {
            case 1: s1pIndexMin = getS1PIndexAtRange(freqRangeMinF1); s1pIndexMax = getS1PIndexAtRange(freqRangeMaxF1); break;
            case 2: s1pIndexMin = getS1PIndexAtRange(freqRangeMinF2); s1pIndexMax = getS1PIndexAtRange(freqRangeMaxF2); break;
            case 3: s1pIndexMin = getS1PIndexAtRange(freqRangeMinF3); s1pIndexMax = getS1PIndexAtRange(freqRangeMaxF3); break;
            default: return;
        }

        if (s1pIndexMin > s1pIndexMax) return;
        DataPoint middlePoint = s1pDataPoints.get((s1pIndexMin + s1pIndexMax) / 2);
        loadImpedance.set(middlePoint.getImpedance());
        frequency.set(middlePoint.getFrequency());
    }

    private int getS1PIndexAtRange(double freq) {
        for (int i = 0; i < s1pDataPoints.size(); i++) {
            if (s1pDataPoints.get(i).getFrequency() >= freq) return i;
        }
        return s1pDataPoints.size() - 1;
    }

    // =============================================================================================
    // Inner Classes
    // =============================================================================================

    public enum Operation {ADD, REMOVE, MODIFY}

    private static class Holder {
        private static final SmithChartViewModel INSTANCE = new SmithChartViewModel();
    }

    public record UndoRedoEntry(Operation operation, int index, Pair<Integer, CircuitElement> element) {
    }
}